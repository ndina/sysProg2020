/*kthreadd routine(kthread.c) */
int kthreadd(void *unused)
{
	 struct task_struct *tsk = current;

	 /* Setup a clean context for our children to inherit. */
	 set_task_comm(tsk, "kthreadd");
	 ignore_signals(tsk);
	 set_cpus_allowed_ptr(tsk, cpu_all_mask);
	 set_mems_allowed(node_states[N_MEMORY]);

	 current->flags |= PF_NOFREEZE;

	for (;;) {
	 set_current_state(TASK_INTERRUPTIBLE);
	 if (list_empty(&kthread_create_list))
	 schedule();
	 __set_current_state(TASK_RUNNING);

	 spin_lock(&kthread_create_lock);
	while (!list_empty(&kthread_create_list)) {
	 struct kthread_create_info *create;

	 create = list_entry(kthread_create_list.next,
	 struct kthread_create_info, list);
	 list_del_init(&create->list);
	 spin_unlock(&kthread_create_lock);

	create_kthread(create); /* creates kernel threads with attributes enqueued */

	 spin_lock(&kthread_create_lock);
	 }
	 spin_unlock(&kthread_create_lock);
	 }

 return 0;
}